---
title: 杂项
layout: default
nav_order: 1000
---

* TOC
{:toc}

# Interval

```python
# span A: [x1, x2]
# span B: [y1, y2]

def dont_overlap(x1, y1, x2, y2):
    return x2 < y1 or x1 > y2

def overlap(x1, y1, x2, y2):
    return x1 <= y2 and y1 <= x2

def merge(intervals):
    intervals.sort(key=operator.itemgetter(0))
    res = []
    res.append(intervals[0])
    
    for i in range(1, len(intervals)):
        curr = intervals[i]
        last = res[-1]
        if curr[0] <= last[1]:
            # 合并
            last[1] = max(last[1], curr[1])
        else:
            # 新的单独区间
            res.append(curr)
    return res
```

# Permutation

```python
def nextPermutation(self, nums: List[int]) -> None:
    """
    Do not return anything, modify nums in-place instead.
    """
    n = len(nums)
    if n == 1: return
    i = n - 2
    while i >= 0 and nums[i] >= nums[i+1]:
        i -= 1
    if i == -1:
        start = 0
        end = n - 1
        while start < end:
            nums[start], nums[end] = nums[end], nums[start]
            start += 1
            end -= 1
    else:
        j = n - 1
        while nums[j] <= nums[i]:
            j -= 1 
        
        nums[i], nums[j] = nums[j], nums[i]

        start = i + 1
        end = n - 1
        while start < end:
            nums[start], nums[end] = nums[end], nums[start]
            start += 1
            end -= 1

def getPermutation(self, n: int, k: int) -> str:
    f = [1]
    for i in range(1, n):
        f.append(f[-1]*i)
    digits = list(range(1, n+1))
    ans = []
    for i in range(n):
        drank = (k - 1) // f[n-1-i]
        k -= drank * f[n-1-i]
        # print(drank, f[n-1-i])
        ans.append(str(digits.pop(drank)))
        # print(ans)
    return "".join(ans)
```
