---
title: 图
layout: default
nav_order: 110
---

* TOC
{:toc}

# 拓扑排序 Topological Sort

```python
def topologicalSort():
    indegree = [0] * numCourses
    adj = defaultdict(list)
    
    for prerequisite in prerequisites:
        adj[prerequisite[1]].append(prerequisite[0])
        indegree[prerequisite[0]] += 1

    queue = deque()
    for i in range(numCourses):
        if indegree[i] == 0:
            queue.append(i)
	
    while queue:
        node = queue.popleft()
        for neighbor in adj[node]:
            indegree[neighbor] -= 1
            if indegree[neighbor] == 0:
                queue.append(neighbor)
```

# Floyd 多源最短路 multi source shortest path
- can deal with negative edge but not negative cycle
- time complexity $$O(N^2)$$
- space complexity $$O(N^3)$$

```python
'''
e:边集
adj:邻接表
s:起点
dis:最短路长度
'''
class Graph:
    def __init__(self, n, edges):
        self.n = n
        self.edges = edges
        self.adj = defaultdict(list)
        for u, v, w in edges:
            self.adj[u].append((v, w))
            self.adj[v].append((u, w))  # If the graph is undirected

    def floyd(self):
        # Time Complexity: O(N^3)
        # Space Complexity: O(N^2)
        dis = [[float('inf')] * self.n for _ in range(self.n)]
        for k in range(self.n):
            dis[k][k] = 0
        for u, v, w in self.edges:
            dis[u][v] = w
            dis[v][u] = w  # If the graph is undirected

        # only use node 1..k as middle point
        for k in range(self.n):
            for i in range(self.n):
                for j in range(self.n):
                    dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])
        return dis
```

# Bellman-Ford 单源最短路 single source shortest path
- can deal with negative edge but not negative cycle
- time complexity $$O(NE)$$ when the graph is dense use dijkstra instead
- space complexity $$O(N)$$

```python
    def bellman_ford(self, start):
        # Time Complexity: O(NE)
        # Space Complexity: O(N)
        dis = [float('inf')] * self.n
        dis[start] = 0

        for _ in range(self.n):
            flag = False
            for u in self.adj:
                for v, w in self.adj[u]:
                    if dis[v] > dis[u] + w:
                        dis[v] = dis[u] + w
                        flag = True
            # 没有可以松弛的边时就停止算法
            if not flag:
                break
        # 第 n 轮循环仍然可以松弛时说明 s 点可以抵达一个负环
        return dis if not flag else None

    def spfa(self, start):
        # Bellman-Ford + 队列优化 => spfa
        # Time Complexity: O(kE) in practice, where k is a small constant
        # Space Complexity: O(N)
        dis = [float('inf')] * self.n
        dis[start] = 0
        queue = deque([start])
        vis = [False] * self.n
        cnt = [0] * n
        vis[start] = True

        while queue:
            u = queue.popleft()
            vis[u] = False

            for v, w in self.adj[u]:
                if dis[v] > dis[u] + w:
                    dis[v] = dis[u] + w
                    cnt[v] = cnt[u] + 1 # 记录最短路经过的边数
                    if cnt[v] >= n:
                        return None
                    # 在不经过负环的情况下，最短路至多经过 n - 1 条边
                    # 因此如果经过了多于 n 条边，一定说明经过了负环
                    if not vis[v]:
                        queue.append(v)
                        vis[v] = True
        return dis
```

# Dijkstra 单源最短路 single source shortest path
- cannot deal with negative edge
- time complexity $$O((N + E)logN)$$ with heap, $$O(N^2 + E)$$ without heap
    - sparse graph when $$E \ll N$$: with heap is better
    - dense graph when $$E \approx N^2$$: without heap is better
- space complexity $$O(N)$$

```python
    def dijkstra(self, start):
        # Time Complexity: O((N + E)logN) with heap
        # Space Complexity: O(N)
        dis = [float('inf')] * self.n
        dis[start] = 0
        q = [(0, start)]
        vis = set()

        while q:
            _, u = heapq.heappop(q)
            if u in vis:
                continue
            vis.add(u)

            for v, w in self.adj[u]:
                if dis[v] > dis[u] + w:
                    dis[v] = dis[u] + w
                    heapq.heappush(q, (dis[v], v))
        return dis
```

# 连通分量
- 并查集(Union Set)
- DFS
- BFS

```python
    def find_connected_components(self):
        uf = UnionSet(self.n)
        for u in self.adj:
            for v, w in self.adj[u]:
                uf.union(u, v)

        components = defaultdict(list)
        for i in range(self.n):
            components[uf.find(i)].append(i)

        return list(components.values())

    def find_connected_components(self):
        def dfs(node, component):
            nonlocal visited
            visited.add(node)
            component.append(node)
            for neighbor, w in self.adj[node]:
                if neighbor not in visited:
                    dfs(neighbor, component)

        visited = set()
        components = []

        for node in range(self.n):
            if node not in visited:
                component = []
                dfs(node, component)
                components.append(component)

        return components

    def find_connected_components(self):
        def bfs(start):
            nonlocal visited
            queue = deque([start])
            visited.add(start)
            component = [start]

            while queue:
                node = queue.popleft()
                for neighbor, w in self.adj[node]:
                    if neighbor not in visited:
                        visited.add(neighbor)
                        queue.append(neighbor)
                        component.append(neighbor)
            
            return component

        visited = set()
        components = []

        for node in range(self.n):
            if node not in visited:
                components.append(bfs(node))

        return components
```
# 最小生成树

- Prim: 二部图
- Krusal: 并查集

```python
    def prim_mst(self):
        # Time complexity: O(E log V)
        visited = [False] * self.n
        min_heap = [(0, 0)]  # (cost, vertex)
        total_cost = 0

        while min_heap:
            cost, u = heapq.heappop(min_heap)
            if visited[u]:
                continue

            visited[u] = True
            total_cost += cost

            for v, w in self.adj[u]:
                if not visited[v]:
                    heapq.heappush(min_heap, (w, v))

        return total_cost

    def kruskal_mst(self):
        # Time complexity: O(E log E) or O(E log V)
        edges = sorted(self.edges, key=itemgetter(2))
        uf = UnionSet(self.n)
        total_cost = 0

        for u, v, w in self.edges:
            if uf.find(u) != uf.find(v):
                uf.union(u, v)
                total_cost += w

        return total_cost
```

